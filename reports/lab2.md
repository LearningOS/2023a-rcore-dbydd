## 编程部分
这道题的编程实现分为两个部分，首先重写ch3的部分，这部分很简单，只要通过PageTable获取物理地址就行；

* 申请内存：
  * 首先，申请内存指的是在进程的页表上申请
  * 可能一次性申请大片内存，也就是会跨页表条目，我使用了偷懒的方法，用一个区间将内存开始和结束之间的所有地址都检查一遍，然后直接用现有的方法申请。
* 释放内存：
  * 感谢神圣的对偶性，很多代码可以从申请内存哪里复制黏贴过来，但是我的代码上有两点不同：
    * 申请大片内存有现成的，但是释放内存我没找到，于是只能一片一片的检查并释放。
    * 我突发奇想，写了个巨大的闭包嵌套，直接给我整迷糊了。

## 问答题

1. SV39页表项
   * 直接上图：![sv39](pic/sv39.png)
翻译成中文就是物理页号（PPN）、保留位（RSW）、访问位（A）、脏位（D）、全局位（G）、用户允许访问位（U）、可执行位（X）、可写位（W）、可读位（R）和有效位（V）。
2. 页表：
   1. 根据文档总结一下，有这三种：
     * 地址不对齐
     * 读空页/读无权限页
     * 写空页/写无权限页
   2. 有三个寄存器：
     * 当前指令的地址存储在 sepc 寄存器
     * 当前处理器模式存储在 scause 寄存器
     * 当前页表项虚拟地址存储在 stval 寄存器
   3. 可以平摊密集的io操作
   4. 大概160MB?
   5. 增加一个dirty位，表示未被读入，使用时检测，发现未读入则中断读取
   6. 标记位V(有效位)会变化
3. 单双页表
   1. 修改当前的页表基址并刷新快表（TLB）
   2. 一样，更改U控制位，让用户模式无法访问
   3. 内存占用小，写代码时心智开销相对更低，更方便。
   4. 两问分别回答：
      1. 进程之间切换时需要修改，此时的操作参考1，由于双页表之间相互隔离，应当是互不影响的。
      2. 单页表的话进程之间、进程与内核态切换时可能要更改页表。
## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > *无*
   >
2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > *无*
   >
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
